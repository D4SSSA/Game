<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <title>Helikopter und Raketen</title>
</head>

<body>
    <script>
        class StartScene extends Phaser.Scene {
            constructor() {
                super({ key: 'StartScene' });
            }

            create() {
                // Titel des Spiels
                this.add.text(625, 360, 'Helikopter und Raketen', { fontSize: '64px', fill: '#FFF' }).setOrigin(0.5);

                // Start-Button
                let startButton = this.add.text(625, 460, 'Start', { fontSize: '32px', fill: '#FFF' })
                    .setOrigin(0.5)
                    .setInteractive();

                startButton.on('pointerdown', () => {
                    this.scene.start('MainScene');
                });

                // Einstellungen-Button
                let settingsButton = this.add.text(625, 510, 'Einstellungen', { fontSize: '32px', fill: '#FFF' })
                    .setOrigin(0.5)
                    .setInteractive();

                settingsButton.on('pointerdown', () => {
                    this.scene.start('SettingsScene');
                });
            }
        }

        class SettingsScene extends Phaser.Scene {
            constructor() {
                super({ key: 'SettingsScene' });
            }

            preload() {
                // Hintergrundbilder laden
                this.load.image('background1', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/background1.png');
                this.load.image('background2', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/background2.png');
                this.load.image('background3', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/background3.png');
            }

            create() {
                // Titel der Einstellungen
                this.add.text(625, 100, 'Einstellungen', { fontSize: '64px', fill: '#FFF' }).setOrigin(0.5);

                // Hintergrundoptionen
                this.add.text(625, 200, 'Wähle den Hintergrund:', { fontSize: '32px', fill: '#FFF' }).setOrigin(0.5);

                let background1Button = this.add.image(450, 300, 'background1')
                    .setDisplaySize(100, 100)
                    .setOrigin(0.5)
                    .setInteractive();

                let background2Button = this.add.image(625, 300, 'background2')
                    .setDisplaySize(100, 100)
                    .setOrigin(0.5)
                    .setInteractive();

                let background3Button = this.add.image(800, 300, 'background3')
                    .setDisplaySize(100, 100)
                    .setOrigin(0.5)
                    .setInteractive();

                background1Button.on('pointerdown', () => {
                    this.setBackground('background1');
                });

                background2Button.on('pointerdown', () => {
                    this.setBackground('background2');
                });

                background3Button.on('pointerdown', () => {
                    this.setBackground('background3');
                });

                // Zurück-Button
                let backButton = this.add.text(625, 400, 'Zurück', { fontSize: '32px', fill: '#FFF' })
                    .setOrigin(0.5)
                    .setInteractive();

                backButton.on('pointerdown', () => {
                    this.scene.start('StartScene');
                });
            }

            setBackground(backgroundKey) {
                localStorage.setItem('selectedBackground', backgroundKey);
                console.log(`Hintergrund gesetzt: ${backgroundKey}`); // Debugging line
            }
        }

        class MainScene extends Phaser.Scene {
            constructor() {
                super({ key: 'MainScene' });
                this.player = null;
                this.rotorSprite = null; // Rotor sprite
                this.shootingEnemyRotors = null; // Gruppe für die Rotoren der schießenden Feinde
                this.cursors = null;
                this.bullets = null;
                this.lastFired = 0;
                this.fireDelay = 250; // Schuss-Delay
                this.enemies = null;
                this.enemySpeed = 100; // Gegner Geschwindigkeit
                this.score = 0;
                this.scoreText = null;
                this.lastDirection = 'down';
                this.startTime = 0;
                this.timerText = null;
                this.spawnDelay = 5000; // Spawn-Delay
                this.enemySpawnEvent = null;
                this.itemSpawnEvent = null;
                this.items = null;
                this.lives = 3; // Initial lives
                this.lifeSprites = []; // Array to store life sprites
                this.glideVelocity = { x: 0, y: 0 }; // Player glide velocity
                this.lifeSpacing = 50;
                this.lifeYPosition = 100;
            }

            preload() {
                // Alle Assets laden
                this.load.spritesheet('rotor', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/rotor.png', { frameWidth: 50, frameHeight: 50 });


                this.load.image('player_up', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/player_up.png');
                this.load.image('player_down', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/player_down.png');
                this.load.image('player_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/player_left.png');
                this.load.image('player_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/player_right.png');
                this.load.image('player_up_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/player_up_left.png');
                this.load.image('player_up_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/player_up_right.png');
                this.load.image('player_down_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/player_down_left.png');
                this.load.image('player_down_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/player_down_right.png');

                this.load.image('bullet_up', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/bullet_up.png');
                this.load.image('bullet_down', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/bullet_down.png');
                this.load.image('bullet_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/bullet_left.png');
                this.load.image('bullet_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/bullet_right.png');
                this.load.image('bullet_up_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/bullet_up_left.png');
                this.load.image('bullet_up_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/bullet_up_right.png');
                this.load.image('bullet_down_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/bullet_down_left.png');
                this.load.image('bullet_down_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/bullet_down_right.png');

                this.load.image('enemy_up', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemy_up.png');
                this.load.image('enemy_down', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemy_down.png');
                this.load.image('enemy_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemy_left.png');
                this.load.image('enemy_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemy_right.png');
                this.load.image('enemy_up_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemy_up_left.png');
                this.load.image('enemy_up_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemy_up_right.png');
                this.load.image('enemy_down_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemy_down_left.png');
                this.load.image('enemy_down_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemy_down_right.png');

                this.load.image('fastEnemy_up', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/fastEnemy_up.png');
                this.load.image('fastEnemy_down', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/fastEnemy_down.png');
                this.load.image('fastEnemy_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/fastEnemy_left.png');
                this.load.image('fastEnemy_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/fastEnemy_right.png');
                this.load.image('fastEnemy_up_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/fastEnemy_up_left.png');
                this.load.image('fastEnemy_up_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/fastEnemy_up_right.png');
                this.load.image('fastEnemy_down_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/fastEnemy_down_left.png');
                this.load.image('fastEnemy_down_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/fastEnemy_down_right.png');

                this.load.image('shootingEnemy_up', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/shootingEnemy_up.png');
                this.load.image('shootingEnemy_down', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/shootingEnemy_down.png');
                this.load.image('shootingEnemy_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/shootingEnemy_left.png');
                this.load.image('shootingEnemy_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/shootingEnemy_right.png');
                this.load.image('shootingEnemy_up_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/shootingEnemy_up_left.png');
                this.load.image('shootingEnemy_up_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/shootingEnemy_up_right.png');
                this.load.image('shootingEnemy_down_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/shootingEnemy_down_left.png');
                this.load.image('shootingEnemy_down_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/shootingEnemy_down_right.png');

                this.load.image('enemyBullet_up', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemyBullet_up.png');
                this.load.image('enemyBullet_down', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemyBullet_down.png');
                this.load.image('enemyBullet_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemyBullet_left.png');
                this.load.image('enemyBullet_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemyBullet_right.png');
                this.load.image('enemyBullet_up_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemyBullet_up_left.png');
                this.load.image('enemyBullet_up_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemyBullet_up_right.png');
                this.load.image('enemyBullet_down_left', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemyBullet_down_left.png');
                this.load.image('enemyBullet_down_right', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemyBullet_down_right.png');

                this.load.image('item', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/item.png');
                this.load.image('life', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/life.png');

                this.load.image('explosion', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/explosion.png');
                this.load.image('enemyExplosion', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/enemyExplosion.png');
                this.load.image('bulletExplosion', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/bulletExplosion.png');


                this.load.image('background1', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/background1.png');
                this.load.image('background2', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/background2.png');
                this.load.image('background3', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/background3.png');

                this.load.image('cloud1', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/cloud.png');
                this.load.image('cloud2', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/cloud.png');
                this.load.image('cloud3', 'https://raw.githubusercontent.com/D4SSSA/Game/main/assets/cloud.png');

            }

            create() {
                // Setze den Hintergrund
                let selectedBackground = localStorage.getItem('selectedBackground') || 'background1';
                console.log(`Geladener Hintergrund: ${selectedBackground}`); // Debugging line
                this.add.image(625, 360, selectedBackground);

                // Initialize player
                this.player = this.physics.add.sprite(625, 360, 'player_down');
                this.player.setCollideWorldBounds(true);

                // Rotor Animation erstellen
                this.anims.create({
                    key: 'rotorAnim',
                    frames: this.anims.generateFrameNumbers('rotor', { start: 0, end: 3 }),
                    frameRate: 16,
                    repeat: -1
                });

                // Setze die Startzeit und den Score zurück
                this.startTime = this.time.now;
                this.score = 0;
                this.lives = 3;

                // Rotor Sprite erstellen und Animation starten
                this.rotorSprite = this.add.sprite(this.player.x, this.player.y - this.player.height / 50, 'rotor');
                this.rotorSprite.play('rotorAnim');

                //Roter für shootingEnemy
                this.shootingEnemyRotors = this.add.group(); // Initialisiere die Gruppe für die Rotoren der schießenden Feinde

                // Create keyboard controls
                this.cursors = this.input.keyboard.createCursorKeys();

                // Create bullets group
                this.playerBullets = this.physics.add.group({
                    defaultKey: 'bullet',
                    maxSize: 10
                });

                this.enemyBullets = this.physics.add.group({
                    defaultKey: 'enemyBullet',
                    maxSize: 20
                });

                // Create enemies group
                this.enemies = this.physics.add.group();

                // Create items group
                this.items = this.physics.add.group();

                // Create life sprites
                const lifeSpacing = this.lifeSpacing; // Increase this value for more space between hearts
                const lifeYPosition = this.lifeYPosition; // Set this value to place the hearts below the score and timer
                for (let i = 0; i < this.lives; i++) {
                    let life = this.add.image(50 + i * lifeSpacing, lifeYPosition, 'life');
                    life.setDepth(10); // Set the depth of life sprites to be above clouds
                    this.lifeSprites.push(life);
                }

                // Event for enemy spawning
                this.enemySpawnEvent = this.time.addEvent({
                    delay: this.spawnDelay,
                    callback: this.spawnEnemy,
                    callbackScope: this,
                    loop: true
                });

                // Event for item spawning
                this.itemSpawnEvent = this.time.addEvent({
                    delay: 25000, // 1 minute delay
                    callback: this.spawnItem,
                    callbackScope: this,
                    loop: true
                });

                // Create clouds group
                this.clouds = this.add.group();

                // Event for cloud spawning
                this.cloudSpawnEvent = this.time.addEvent({
                    delay: 3000, // Adjust the delay for cloud spawning
                    callback: this.spawnCloud,
                    callbackScope: this,
                    loop: true
                });

                // Colliders
                this.physics.add.collider(this.playerBullets, this.enemies, this.hitEnemy, null, this);
                this.physics.add.collider(this.player, this.enemies, this.playerHit, null, this);
                this.physics.add.collider(this.player, this.enemyBullets, this.playerHitByBullet, null, this);
                this.physics.add.collider(this.playerBullets, this.enemyBullets, this.hitEnemyBullet, null, this);
                this.physics.add.collider(this.player, this.items, this.collectItem, null, this);

                // Score display
                this.scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '32px', fill: '#FFF' });
                this.scoreText.setDepth(10); // Set the depth of score text to be above clouds

                // Timer display
                this.timerText = this.add.text(16, 50, 'Time: 0:00', { fontSize: '32px', fill: '#FFF' });
                this.timerText.setDepth(10); // Set the depth of timer text to be above clouds
            }


            update(time, delta) {
                const glideFactor = 0.95;
                const glideThreshold = 1;

                if (this.cursors.left.isDown) {
                    this.player.setVelocityX(-200);
                    this.glideVelocity.x = -200;
                } else if (this.cursors.right.isDown) {
                    this.player.setVelocityX(200);
                    this.glideVelocity.x = 200;
                } else {
                    this.glideVelocity.x *= glideFactor;
                    if (Math.abs(this.glideVelocity.x) < glideThreshold) {
                        this.glideVelocity.x = 0;
                    }
                    this.player.setVelocityX(this.glideVelocity.x);
                }

                if (this.cursors.up.isDown) {
                    this.player.setVelocityY(-200);
                    this.glideVelocity.y = -200;
                } else if (this.cursors.down.isDown) {
                    this.player.setVelocityY(200);
                    this.glideVelocity.y = 200;
                } else {
                    this.glideVelocity.y *= glideFactor;
                    if (Math.abs(this.glideVelocity.y) < glideThreshold) {
                        this.glideVelocity.y = 0;
                    }
                    this.player.setVelocityY(this.glideVelocity.y);
                }

                this.clouds.children.iterate(function (cloud) {
                    cloud.setDepth(1);
                }, this);

                this.player.setDepth(0);
                this.enemies.children.iterate(function (enemy) {
                    enemy.setDepth(0);
                }, this);


                // Update player direction
                if (this.cursors.left.isDown && this.cursors.up.isDown) {
                    this.lastDirection = 'up_left';
                    this.player.setTexture('player_up_left');
                } else if (this.cursors.left.isDown && this.cursors.down.isDown) {
                    this.lastDirection = 'down_left';
                    this.player.setTexture('player_down_left');
                } else if (this.cursors.right.isDown && this.cursors.up.isDown) {
                    this.lastDirection = 'up_right';
                    this.player.setTexture('player_up_right');
                } else if (this.cursors.right.isDown && this.cursors.down.isDown) {
                    this.lastDirection = 'down_right';
                    this.player.setTexture('player_down_right');
                } else if (this.cursors.left.isDown) {
                    this.lastDirection = 'left';
                    this.player.setTexture('player_left');
                } else if (this.cursors.right.isDown) {
                    this.lastDirection = 'right';
                    this.player.setTexture('player_right');
                } else if (this.cursors.up.isDown) {
                    this.lastDirection = 'up';
                    this.player.setTexture('player_up');
                } else if (this.cursors.down.isDown) {
                    this.lastDirection = 'down';
                    this.player.setTexture('player_down');
                }

                // Aktualisiere die Position des Spieler-Rotors
                if (this.rotorSprite) {
                    this.rotorSprite.setPosition(this.player.x, this.player.y - this.player.height + 50);
                }

                // Aktualisiere die Position der Rotoren der schießenden Feinde
                this.enemies.children.iterate(function (enemy) {
                    if (enemy.active && enemy.getData('type') === 'shootingEnemy') {
                        let enemyRotor = enemy.getData('rotor');
                        if (enemyRotor) {
                            enemyRotor.setPosition(enemy.x, enemy.y - enemy.height + 50);
                        }
                    }
                }, this);


                // Handle shooting with delay
                if (this.cursors.space.isDown && time > this.lastFired + this.fireDelay) {
                    this.lastFired = time;
                    this.shootBullet();
                }

                // Remove bullets that are out of bounds
                this.playerBullets.children.each(function (b) {
                    if (b.active && (b.y < 0 || b.y > 720 || b.x < 0 || b.x > 1250)) {
                        b.setActive(false);
                        b.setVisible(false);
                        b.body.enable = false;
                    }
                });

                this.enemyBullets.children.each(function (b) {
                    if (b.active && (b.y < 0 || b.y > 720 || b.x < 0 || b.x > 1250)) {
                        b.setActive(false);
                        b.setVisible(false);
                        b.body.enable = false;
                    }
                });

                // Update enemies movement towards player
                this.enemies.children.iterate(function (enemy) {
                    if (enemy.active) {
                        this.physics.moveToObject(enemy, this.player, this.enemySpeed);
                        if (enemy.getData('type') === 'shootingEnemy' && time > enemy.getData('lastFired') + 2000) {
                            enemy.setData('lastFired', time);
                            this.shootFromEnemy(enemy);
                        }

                        // Update enemy sprite based on direction
                        let angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, this.player.x, this.player.y);
                        this.updateEnemyDirection(enemy, angle);
                    }
                }, this);

                // Update timer display
                const elapsed = Math.floor((time - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                this.timerText.setText(`Time: ${minutes}:${seconds.toString().padStart(2, '0')}`);

                // Update spawn delay based on score
                this.updateSpawnDelay();
            }

            shootBullet() {
                let bullet = this.playerBullets.get(this.player.x, this.player.y);
                if (bullet) {
                    bullet.setActive(true);
                    bullet.setVisible(true);
                    bullet.body.enable = true; // Enable physics body
                    // Setzt die Geschwindigkeit und das Sprite basierend auf der letzten Blickrichtung
                    if (this.lastDirection === 'left') {
                        bullet.setVelocityX(-300);
                        bullet.setVelocityY(0);
                        bullet.setTexture('bullet_left');
                    } else if (this.lastDirection === 'right') {
                        bullet.setVelocityX(300);
                        bullet.setVelocityY(0);
                        bullet.setTexture('bullet_right');
                    } else if (this.lastDirection === 'up') {
                        bullet.setVelocityY(-300);
                        bullet.setVelocityX(0);
                        bullet.setTexture('bullet_up');
                    } else if (this.lastDirection === 'down') {
                        bullet.setVelocityY(300);
                        bullet.setVelocityX(0);
                        bullet.setTexture('bullet_down');
                    } else if (this.lastDirection === 'up_left') {
                        bullet.setVelocityY(-300);
                        bullet.setVelocityX(-300);
                        bullet.setTexture('bullet_up_left');
                    } else if (this.lastDirection === 'up_right') {
                        bullet.setVelocityY(-300);
                        bullet.setVelocityX(300);
                        bullet.setTexture('bullet_up_right');
                    } else if (this.lastDirection === 'down_left') {
                        bullet.setVelocityY(300);
                        bullet.setVelocityX(-300);
                        bullet.setTexture('bullet_down_left');
                    } else if (this.lastDirection === 'down_right') {
                        bullet.setVelocityY(300);
                        bullet.setVelocityX(300);
                        bullet.setTexture('bullet_down_right');
                    }
                }
            }

            spawnEnemy() {
                let x = Phaser.Math.Between(0, 1250);
                let y = Phaser.Math.Between(0, 720);

                // Adjust spawn position if too close to the player
                if (Phaser.Math.Distance.Between(x, y, this.player.x, this.player.y) < 100) {
                    x += (x > this.player.x) ? 100 : -100;
                    y += (y > this.player.y) ? 100 : -100;
                }

                let enemyType = Phaser.Math.Between(1, 3);
                let enemy;

                if (enemyType === 1) {
                    enemy = this.enemies.create(x, y, 'enemy_down'); // Default to down direction
                    enemy.setData('type', 'enemy');
                    enemy.setVelocity(this.enemySpeed, this.enemySpeed);
                } else if (enemyType === 2) {
                    enemy = this.enemies.create(x, y, 'fastEnemy_down'); // Default to down direction
                    enemy.setData('type', 'fastEnemy');
                    enemy.setVelocity(this.enemySpeed * 2, this.enemySpeed * 2); // Double the speed for fast enemies
                } else if (enemyType === 3) {
                    enemy = this.enemies.create(x, y, 'shootingEnemy_down'); // Default to down direction
                    enemy.setData('type', 'shootingEnemy');
                    enemy.setData('lastFired', this.time.now); // Set initial last fired to now
                    enemy.setVelocity(this.enemySpeed, this.enemySpeed);

                    // Rotor Sprite für den schießenden Feind erstellen und Animation starten
                    let enemyRotor = this.add.sprite(enemy.x, enemy.y - enemy.height / 2, 'rotor');
                    enemyRotor.play('rotorAnim');
                    enemy.setData('rotor', enemyRotor); // Rotor als Daten für den Feind speichern
                    this.shootingEnemyRotors.add(enemyRotor); // Rotor zur Gruppe hinzufügen
                }

                enemy.setCollideWorldBounds(true);
                enemy.setActive(true);
                enemy.setVisible(true);
                enemy.body.enable = true;
            }


            updateEnemyDirection(enemy, angle) {
                if (angle >= -Math.PI / 8 && angle < Math.PI / 8) {
                    enemy.setTexture(enemy.getData('type') + '_right');
                } else if (angle >= Math.PI / 8 && angle < 3 * Math.PI / 8) {
                    enemy.setTexture(enemy.getData('type') + '_down_right');
                } else if (angle >= 3 * Math.PI / 8 && angle < 5 * Math.PI / 8) {
                    enemy.setTexture(enemy.getData('type') + '_down');
                } else if (angle >= 5 * Math.PI / 8 && angle < 7 * Math.PI / 8) {
                    enemy.setTexture(enemy.getData('type') + '_down_left');
                } else if (angle >= 7 * Math.PI / 8 || angle < -7 * Math.PI / 8) {
                    enemy.setTexture(enemy.getData('type') + '_left');
                } else if (angle >= -7 * Math.PI / 8 && angle < -5 * Math.PI / 8) {
                    enemy.setTexture(enemy.getData('type') + '_up_left');
                } else if (angle >= -5 * Math.PI / 8 && angle < -3 * Math.PI / 8) {
                    enemy.setTexture(enemy.getData('type') + '_up');
                } else if (angle >= -3 * Math.PI / 8 && angle < -Math.PI / 8) {
                    enemy.setTexture(enemy.getData('type') + '_up_right');
                }
            }

            spawnItem() {
                if (this.score >= 2000) {
                    let x = Phaser.Math.Between(0, 1250);
                    let y = Phaser.Math.Between(0, 720);

                    // Bearbeiten Falls zu nah am Spieler
                    if (Phaser.Math.Distance.Between(x, y, this.player.x, this.player.y) < 100) {
                        x += (x > this.player.x) ? 100 : -100;
                        y += (y > this.player.y) ? 100 : -100;
                    }

                    let item = this.items.create(x, y, 'item');
                    item.setCollideWorldBounds(true);
                    item.setActive(true);
                    item.setVisible(true);
                    item.body.enable = true;
                }
            }

            shootFromEnemy(enemy) {
                let bullet = this.enemyBullets.get(enemy.x, enemy.y);
                if (bullet) {
                    bullet.setActive(true);
                    bullet.setVisible(true);
                    bullet.body.enable = true;  // Enable physics body

                    // Berechnet die Richtung zum Spieler und setzt das entsprechende Sprite
                    var angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, this.player.x, this.player.y);
                    this.physics.velocityFromRotation(angle, 300, bullet.body.velocity);

                    if (angle >= -Math.PI / 8 && angle < Math.PI / 8) {
                        bullet.setTexture('enemyBullet_right');
                    } else if (angle >= Math.PI / 8 && angle < 3 * Math.PI / 8) {
                        bullet.setTexture('enemyBullet_down_right');
                    } else if (angle >= 3 * Math.PI / 8 && angle < 5 * Math.PI / 8) {
                        bullet.setTexture('enemyBullet_down');
                    } else if (angle >= 5 * Math.PI / 8 && angle < 7 * Math.PI / 8) {
                        bullet.setTexture('enemyBullet_down_left');
                    } else if (angle >= 7 * Math.PI / 8 || angle < -7 * Math.PI / 8) {
                        bullet.setTexture('enemyBullet_left');
                    } else if (angle >= -7 * Math.PI / 8 && angle < -5 * Math.PI / 8) {
                        bullet.setTexture('enemyBullet_up_left');
                    } else if (angle >= -5 * Math.PI / 8 && angle < -3 * Math.PI / 8) {
                        bullet.setTexture('enemyBullet_up');
                    } else if (angle >= -3 * Math.PI / 8 && angle < -Math.PI / 8) {
                        bullet.setTexture('enemyBullet_up_right');
                    }

                    // Event-Handler, der ausgelöst wird, wenn das Geschoss die Weltgrenzen berührt
                    bullet.body.onWorldBounds = true;
                    bullet.body.world.on('worldbounds', (body) => {
                        // Prüfe, ob der Körper, der die Weltgrenzen berührt, zu einem aktiven Geschoss gehört
                        if (body.gameObject === bullet) {
                            bullet.setActive(false).setVisible(false);
                            bullet.body.enable = false;
                        }
                    });
                }
            }

            collectItem(player, item) {
                item.setActive(false).setVisible(false);
                item.body.enable = false;

                let enemyCount = this.enemies.countActive(true);
                this.enemies.children.each((enemy) => {
                    if (enemy.active) {
                        enemy.setActive(false).setVisible(false);
                        enemy.body.enable = false;
                    }
                });

                this.score += enemyCount * 100; // Add points for all enemies destroyed
                this.scoreText.setText('Score: ' + this.score);
            }

            hitEnemy(bullet, enemy) {
                if (bullet.active && enemy.active) {
                    bullet.setActive(false).setVisible(false);
                    bullet.body.enable = false;
                    enemy.setActive(false).setVisible(false);
                    enemy.body.enable = false;

                    // Punktzahl um 100 erhöhen und Text aktualisieren
                    this.score += 100;
                    this.scoreText.setText('Score: ' + this.score);

                    // Explosion anzeigen
                    let enemyExplosion = this.add.image(enemy.x, enemy.y, 'enemyExplosion');

                    // Explosion nach 1 Sekunde entfernen
                    this.time.addEvent({
                        delay: 250,
                        callback: () => {
                            enemyExplosion.destroy();
                        }
                    });

                    // Entferne den Rotor des zerstörten Feindes
                    let enemyRotor = enemy.getData('rotor');
                    if (enemyRotor) {
                        enemyRotor.destroy();
                    }
                }
            }

            spawnCloud() {
                let cloudType = Phaser.Math.Between(1, 3);
                let cloudImage;
                let alpha;

                if (cloudType === 1) {
                    cloudImage = 'cloud1';
                    alpha = 0.3; // Sehr durchsichtig
                } else if (cloudType === 2) {
                    cloudImage = 'cloud2';
                    alpha = 0.6; // Mittel durchsichtig
                } else {
                    cloudImage = 'cloud3';
                    alpha = 1.0; // Nicht durchsichtig
                }

                let x = Phaser.Math.Between(0, 1250);
                let cloud = this.add.image(x, 1250, cloudImage).setAlpha(alpha); // Spawnen außerhalb des Sichtfeldes (y = 800)
                cloud.setDepth(1); // Set the depth of clouds to be below score, timer and life sprites
                this.clouds.add(cloud);

                this.tweens.add({
                    targets: cloud,
                    y: -cloud.height,
                    duration: 60000, // Langsame Bewegung (30 Sekunden)
                    ease: 'Linear',
                    onComplete: () => {
                        cloud.destroy();
                    }
                });
            }



            hitEnemyBullet(playerBullet, enemyBullet) {
                if (playerBullet.active && enemyBullet.active) {
                    playerBullet.setActive(false).setVisible(false);
                    playerBullet.body.enable = false;
                    enemyBullet.setActive(false).setVisible(false);
                    enemyBullet.body.enable = false;

                    // Punktzahl um 50 erhöhen und Text aktualisieren
                    this.score += 50;
                    this.scoreText.setText('Score: ' + this.score);

                    // Explosion anzeigen
                    let bulletExplosion = this.add.image(enemyBullet.x, enemyBullet.y, 'bulletExplosion');

                    // Explosion nach 1 Sekunde entfernen
                    this.time.addEvent({
                        delay: 250,
                        callback: () => {
                            bulletExplosion.destroy();
                        }
                    });
                }
            }


            playerHit(player, enemy) {
                if (enemy.active) {
                    if (this.lives > 0) {
                        this.lives -= 1;
                        this.lifeSprites[this.lives].setVisible(false);

                        enemy.setActive(false).setVisible(false);
                        enemy.body.enable = false;

                        // Entferne den Rotor des zerstörten Feindes
                        let enemyRotor = enemy.getData('rotor');
                        if (enemyRotor) {
                            enemyRotor.destroy();
                        }
                    }

                    if (this.lives <= 0) {
                        const finalTime = Math.floor((this.time.now - this.startTime) / 1000);
                        const finalMinutes = Math.floor(finalTime / 60);
                        const finalSeconds = finalTime % 60;
                        const formattedFinalTime = `${finalMinutes}:${finalSeconds.toString().padStart(2, '0')}`;
                        this.scene.start('GameOverScene', { score: this.score, time: formattedFinalTime });
                    }

                    // Explosion anzeigen
                    let explosion = this.add.image(player.x, player.y, 'explosion');

                    // Explosion nach 1 Sekunde entfernen
                    this.time.addEvent({
                        delay: 200,
                        callback: () => {
                            explosion.destroy();
                        }
                    });
                }
            }

            playerHitByBullet(player, bullet) {
                if (bullet.active) {
                    bullet.setActive(false).setVisible(false);
                    bullet.body.enable = false;

                    if (this.lives > 0) {
                        this.lives -= 1;
                        this.lifeSprites[this.lives].setVisible(false);
                    }

                    if (this.lives <= 0) {
                        const finalTime = Math.floor((this.time.now - this.startTime) / 1000);
                        const finalMinutes = Math.floor(finalTime / 60);
                        const finalSeconds = finalTime % 60;
                        const formattedFinalTime = `${finalMinutes}:${finalSeconds.toString().padStart(2, '0')}`;
                        this.scene.start('GameOverScene', { score: this.score, time: formattedFinalTime });
                    }

                    // Explosion anzeigen
                    let explosion = this.add.image(player.x, player.y, 'explosion');

                    // Explosion nach 1 Sekunde entfernen
                    this.time.addEvent({
                        delay: 200,
                        callback: () => {
                            explosion.destroy();
                        }
                    });
                }
            }



            updateSpawnDelay() {
                let newDelay;
                if (this.score < 1000) {
                    newDelay = 5000;
                } else if (this.score < 2000) {
                    newDelay = 4000;
                } else if (this.score < 3000) {
                    newDelay = 3000;
                } else if (this.score < 4000) {
                    newDelay = 2000;
                } else {
                    newDelay = 1000;
                }

                if (newDelay !== this.spawnDelay) {
                    this.spawnDelay = newDelay;
                    console.log(`Spawn delay updated to: ${this.spawnDelay}`); // Debugging line
                    this.enemySpawnEvent.reset({ delay: this.spawnDelay, callback: this.spawnEnemy, callbackScope: this, loop: true });
                }
            }
        }

        

        class GameOverScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameOverScene' });
                this.finalScore = 0;
                this.finalTime = '0:00';
            }

            init(data) {
                this.finalScore = data.score;
                this.finalTime = data.time;
            }

            create() {
                this.add.text(625, 360, 'Game Over', { fontSize: '64px', fill: '#FFF' }).setOrigin(0.5);
                this.add.text(625, 460, 'Final Score: ' + this.finalScore, { fontSize: '32px', fill: '#FFF' }).setOrigin(0.5);
                this.add.text(625, 510, `Time: ${this.finalTime}`, { fontSize: '32px', fill: '#FFF' }).setOrigin(0.5);

                let restartButton = this.add.text(625, 560, 'Neustart', { fontSize: '32px', fill: '#FFF' })
                    .setOrigin(0.5)
                    .setInteractive();
                restartButton.on('pointerdown', () => {
                    this.scene.start('StartScene');
                });
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 1250,
            height: 720,
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false
                }
            },
            scene: [StartScene, MainScene, GameOverScene, SettingsScene]
        };

        const game = new Phaser.Game(config);
    </script>
</body>

</html>